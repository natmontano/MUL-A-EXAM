<!DOCTYPE html>
<head>
    <title>Titulo</title>
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; }
        #text {
            position: absolute;
            padding: 10px;
            width: 100%;
            text-align: center;
            color: #bec3c8;
        }
    </style>
</head>
<body>
    <div id="text">	PIRAMIDE POLIGONAL <br/>
        NATALIA MONTAÑO<br/>
    </div>
</body>
</html>
    <script src="https://threejs.org/build/three.js"></script>
    <script>

    // Dimensiones de la ventana
    const ANCHO =1920;
    const ALTO = 1000;

    // Configuración de la escena
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, ANCHO / ALTO, 0.1, 1000);
    camera.position.z = 5;
  
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(ANCHO, ALTO);
    document.body.appendChild(renderer.domElement);

    // Función para generar las coordenadas de un polígono regular
    function poligono(lados, radio) {
      const vertices = [];
      const angulo = (2 * Math.PI) / lados;
      for (let i = 0; i < lados; i++) {
        const x = radio * Math.cos(angulo * i);
        const y = radio * Math.sin(angulo * i);
        vertices.push(new THREE.Vector3(x, y, 0));
      }
      return vertices;
    }

    // Función para crear una pirámide recortada de base poligonal
    function crearPiramide(ladosBase, ladosSuperior, altura, color) {
      const geometria = new THREE.ConeGeometry(1, altura, ladosBase, ladosSuperior);
      const material = new THREE.MeshBasicMaterial({ color: color });
      const piramide = new THREE.Mesh(geometria, material);
      return piramide;
    }

    var NUM_PIRAMIDES=1;

    // Crear las pirámides y agregarlas a la escena
    for (let i = 0; i < NUM_PIRAMIDES; i++) {
      const ladosBase = Math.floor(Math.random() * 5) + 3; // Entre 3 y 7 lados
      const ladosSuperior = Math.floor(Math.random() * 5) + 3; // Entre 3 y 7 lados
      const altura = Math.random() * 2 + 1; // Entre 1 y 3 unidades de altura
      const color = Math.random() * 0xffffff; // Color aleatorio
      const piramide = crearPiramide(ladosBase, ladosSuperior, altura, color);
      scene.add(piramide);
    }

     // Función para repetir las figuras en la escena
     function repetirFiguras() {
      const numRepeticiones = 8;
      const ladosBase = Math.floor(Math.random() * 5) + 2; // Entre 3 y 7 lados
      const ladosSuperior = Math.floor(Math.random() * 5) + 2; // Entre 3 y 7 lados
      const altura = Math.random() * 2 + 1; // Entre 1 y 3 unidades de altura

      for (let i = 0; i < numRepeticiones; i++) {
        const color = Math.random() * 0xffffff; // Color aleatorio
        const piramide = crearPiramide(ladosBase, ladosSuperior, altura, color);
        scene.add(piramide);

       // Posición de cada figura en una cuadrícula de 2x4
        const posX = (i % 4) * 2-2; 
        const posY = Math.floor(i / 4) * 2-2; 
        piramide.position.set(posX, posY, 0);
      }
    }

    // Llamar a la función para repetir las figuras
    repetirFiguras();
    function recortarFigura(geometria) {
  // Obtener la cantidad de vértices en la geometría
  const numVertices = geometria.vertices.length;

  // Calcular la mitad del ancho de la figura
  let maxPosX = Number.NEGATIVE_INFINITY;
  let minPosX = Number.POSITIVE_INFINITY;
  for (let i = 0; i < numVertices; i++) {
    const vertex = geometria.vertices[i];
    if (vertex.x > maxPosX) {
      maxPosX = vertex.x;
    }
    if (vertex.x < minPosX) {
      minPosX = vertex.x;
    }
  }
  const halfWidth = (maxPosX - minPosX) / 2;

  // Recortar la figura en forma de L en la parte inferior
  for (let i = 0; i < numVertices; i++) {
    const vertex = geometria.vertices[i];
    if (vertex.x < minPosX + halfWidth && vertex.y < -halfWidth) {
      vertex.y = -halfWidth;
    }
  }

  // Actualizar la geometría
  geometria.verticesNeedUpdate = true;
}

    // Configurar la animación y renderizar la escena
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
